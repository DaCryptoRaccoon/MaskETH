import cmd
import requests
import logging
from web3 import Web3
from eth_account import Account
import os
import secrets
import csv
import subprocess
from dotenv import load_dotenv
from datetime import datetime
import sys
import glob
import decimal
import random
import time
import web3.exceptions
import getpass
import json

# Load .env variables
load_dotenv()

logging.basicConfig(filename='eth_mask.log', level=logging.INFO)


class EthMixerCmd(cmd.Cmd):
    intro = '''
    :::::::::: ::::::::::: :::    ::: ::::    ::::      :::      ::::::::  :::    ::: 
    :+:            :+:     :+:    :+: +:+:+: :+:+:+   :+: :+:   :+:    :+: :+:   :+:  
    +:+            +:+     +:+    +:+ +:+ +:+:+ +:+  +:+   +:+  +:+        +:+  +:+   
    +#++:++#       +#+     +#++:++#++ +#+  +:+  +#+ +#++:++#++: +#++:++#++ +#++:++    
    +#+            +#+     +#+    +#+ +#+       +#+ +#+     +#+        +#+ +#+  +#+   
    #+#            #+#     #+#    #+# #+#       #+# #+#     #+# #+#    #+# #+#   #+#  
    ##########     ###     ###    ### ###       ### ###     ###  ########  ###    ### CLI v1.0
    -------------------------------------------------------------------------------------------------------------------
    Donations ETH: 0xE2f739D09e372a627c563C642321e51b9E64BcB3
    Donations BTC: 19Qz2mid5CsGQ49Zztrt8k2NhGGUMT1S8L
    Donations LTC: LTGNf2ANWQGZCXmu5NPACUhtCgNHHWCZVs
    -------------------------------------------------------------------------------------------------------------------

    Welcome to ETHMask!

    This command line interface enhances privacy by distributing funds through a chain of Ethereum addresses.

    Here's a quick guide on how to use it:

    Enter your wallet public key, private key, Etherscan API key and Infura API key into the .env file. All are required for the scripts to work correctly.

    The wallet public and private keys are used to send the funds to the new addresses generated by ETHMask.

    The default RPC endpoint is Infura, but it can be overridden by a custom RPC endpoint. There is also an optional proxy setting.

    
    MAIN COMMANDS:

    automated_mode <number_of_addresses>
                                An automated way to run the new_accounts and send_transactions commands, followed by the sweep script.
                                Run the automated mode for generating addresses, sending transactions, and running the consolidation script
                                The automated mode sets a random amount to send to each address at a random time delay between transactions.
                                It also checks on-chain for confirmation before sending the next transaction [TXID <Address> | Confirmed ✔].
                                After the automated mode is over, user will be asked if they want to run the consolidation script 
                                to send all funds to the Master address.
                                WARNING:
                                    Always double check that the master address is correct, as all funds will be sent there.
                                    Make certain that you know its private key.
                                    DO NOT MAKE A MISTAKE, OR YOU WILL LOSE ALL THE FUNDS!

    new_accounts <number>       Generates the specified number of new Ethereum accounts
                                For example, 'new_accounts 100' will create 100 new accounts.

    send_transactions           Prompts for a CSV file of accounts (generated by new_accounts) and sends transactions to those accounts

    
    OTHER COMMANDS:
    
    add_address_label <address> <label>     Assign a label to an Ethereum address in the address book
                                            The address book is a collection of addresses and their associated labels. 

    address_balance <address>   Display the balance in ether of a specific Ethereum address using the Etherscan API

    address_book                Display the list of addresses and their labels in the address book

    address_history <address>   View the transaction history of a specific Ethereum address using the Etherscan API
                                Details include transaction hash, sender, receiver and value.

    decrypt_private_key         Decrypt the encrypted private key using the passphrase
                                User will be prompted for the path to the encrypted private key JSON file, and the passphrase.
                                Encryption is handled by the w3.eth.account decrypt function.

    encrypt_private_key         Encrypt the private key using a passphrase, and save to a JSON file
                                User will be prompted for the private key.
                                Encryption is handled by the w3.eth.account.encrypt function.

    estimate_fee                Estimate the transaction fee based on the current gas price
                                This is done by retrieving the current gas price from the network and converting it to ether.

    exit                        Exit the shell

    generate_encrypted_key      Generate an encrypted private key with a passphrase and save to a JSON file
                                User will be prompted for a passphrase. Encryption is handled by the w3.eth.account.encrypt function.

    help <command>              Display help for the specified command                        
                                
    proxy <Proxy_URL>           Set the Proxy URL (optional)
                                For example, 'proxy http://127.0.0.1:9050' will set the Proxy URL to a local Tor proxy.

    remove_address_label <address>          Remove the label associated with the specified Ethereum address from the address book

    rpc <RPC_endpoint>          Set the RPC endpoint (optional)
                                For example, 'rpc https://mainnet.infura.io/v3/YOUR-PROJECT-ID' will set the RPC endpoint to the provided Infura address.

    switch_network              Switch to a different Ethereum network by configuring the RPC endpoint
                                User will be prompted for the new RPC endpoint.
                                The infura_endpoint attribute of the EthMixerCmd class will be updated.
    '''
    prompt = '(ethmask) '
    infura_endpoint = f'https://sepolia.infura.io/v3/{os.getenv("INFURA_API_KEY")}'  # Default Infura endpoint
    address_book = {}

    def do_rpc(self, arg):
        'Set the RPC endpoint: rpc <RPC_endpoint>'
        self.infura_endpoint = arg

    def do_proxy(self, arg):
        'Set the Proxy URL: proxy <Proxy_URL>'
        os.environ['http_proxy'] = arg
        os.environ['https_proxy'] = arg

    def do_new_accounts(self, arg):
        'Generate new accounts: new_accounts <number_of_accounts>'
        try:
            number_of_accounts = int(arg)
        except ValueError:
            print("Invalid number of accounts. Please enter a valid integer.")
            return

        logging.info(f'Creating {number_of_accounts} new accounts')
        new_accounts = [Account.create(secrets.token_hex(32)) for i in range(number_of_accounts)]

        # Create the Accounts directory if it doesn't exist
        if not os.path.exists('Accounts'):
            os.makedirs('Accounts')

        # Use the date and time string to create a unique CSV filename within the Accounts directory
        now = datetime.now()
        datetime_string = now.strftime("%Y%m%d_%H%M%S")
        csv_filename = os.path.join('Accounts', f'Accounts_{datetime_string}.csv')

        # Write the new accounts data to a CSV file
        with open(csv_filename, 'w') as f:
            writer = csv.writer(f)
            writer.writerow(["Address", "Private Key"])
            for account in new_accounts:
                writer.writerow([account.address, account._private_key.hex()])

        logging.info(f'Successfully created {number_of_accounts} new accounts')

    def do_send_transactions(self, arg):
        'Send transactions: send_transactions'
        csv_files = glob.glob('Accounts/*.csv')  # Change the pattern to list files within the Accounts directory
        for i, csv_file in enumerate(csv_files):
            print(f'{i + 1}. {csv_file}')
        file_number = int(input('Please enter the number of the CSV file you want to send transactions to: ')) - 1
        if file_number < 0 or file_number >= len(csv_files):
            print('Invalid selection. Please try again.')
            return
        selected_file = csv_files[file_number]
        logging.info(f'Sending transactions to accounts in {selected_file}')

        # Fetch the current balance of the sender
        try:
            balance_url = f"https://api-sepolia.etherscan.io/api?module=account&action=balance&address={my_address}&tag=latest&apikey={api_key}"
            balance_response = requests.get(balance_url)
            balance_result = balance_response.json()["result"]
            if balance_result == 'Error! Invalid address format':
                print('Invalid sender address. Please check your wallet address in the .env file.')
                return
            balance = int(balance_result)  # Balance in wei
            balance_eth = w3.from_wei(balance, "ether")  # Balance in ether
            print(f"Your current balance is: {balance_eth} ETH")
        except web3.exceptions.ConnectivityError:
            print('Unable to connect to the Ethereum network. Please check your internet connection.')
            return

        # Read the selected CSV file
        with open(selected_file, 'r') as f:
            reader = csv.reader(f)
            next(reader)  # skip the header
            addresses = [row[0] for row in reader]  # assuming addresses are in the first column

        # Ask the user to select the amount sending method
        print('Please select the amount to send:')
        print('1. Send a custom value in ETH')
        print('2. Send a random amount')
        selection = input('Please enter the number corresponding to the option you want: ')

        if selection == '1':
            amount_eth = decimal.Decimal(input('Please enter the custom value in ETH: '))
            if amount_eth < 0 or amount_eth > balance_eth:
                print('Invalid custom value. Please enter a valid value.')
                return
        elif selection == '2':
            min_amount_eth = float(input('Please enter the minimum amount in ETH: '))
            max_amount_eth = None
            while max_amount_eth is None:
                max_amount_input = input('Please enter the maximum amount in ETH: ')
                if max_amount_input == '':
                    print('Invalid maximum amount. Please enter a valid value.')
                else:
                    try:
                        max_amount_eth = float(max_amount_input)
                        if max_amount_eth <= 0 or max_amount_eth > balance_eth or min_amount_eth >= max_amount_eth:
                            print('Invalid maximum amount. Please enter a valid value.')
                            max_amount_eth = None
                    except ValueError:
                        print('Invalid maximum amount. Please enter a valid value.')
        else:
            print('Invalid selection. Please try again.')
            return

        # Get the current gas price
        gas_price = w3.eth.gas_price

        # Get the current nonce of the sender
        nonce = w3.eth.get_transaction_count(my_address)

        # Prepare and send transactions
        for address in addresses:
            if selection == '1':
                amount = w3.to_wei(amount_eth, "ether")
            else:
                amount_eth = random.uniform(min_amount_eth, max_amount_eth)
                amount = w3.to_wei(amount_eth, "ether")

            transaction = {
                'from': my_address,
                'to': address,
                'value': amount,
                'gas': 2000000,
                'gasPrice': gas_price,
                'nonce': nonce,  # Include the nonce field
            }
            signed_txn = w3.eth.account.sign_transaction(transaction, private_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            print(f'Sent {amount_eth} ETH from {my_address} to {address} in transaction {tx_hash.hex()}')
            nonce += 1  # Increment the nonce for the next transaction

            time.sleep(38)  # Wait for 38 seconds before checking transaction status
            check_transaction_status(tx_hash)  # Check transaction status

        print('Sweep completed! Would you like to run the consolidation script (yes/no)?')
        user_input = input().lower()
        if user_input == 'yes':
            print('Running ETHSweeper.py...')
            subprocess.run(['python3', 'ETHSweeper.py'])

    def do_automated_mode(self, arg):
        'Run the automated mode for generating addresses, sending transactions, and running the consolidation script: automated_mode <number_of_addresses>'
        try:
            number_of_addresses = int(arg)
        except ValueError:
            print("Invalid number of addresses. Please enter a valid integer.")
            return

        logging.info(f'Generating {number_of_addresses} addresses for automated mode')

        # Generate new accounts
        new_accounts = [Account.create(secrets.token_hex(32)) for i in range(number_of_addresses)]

        # Create the Accounts directory if it doesn't exist
        if not os.path.exists('Accounts'):
            os.makedirs('Accounts')

        # Use the date and time string to create a unique CSV filename within the Accounts directory
        now = datetime.now()
        datetime_string = now.strftime("%Y%m%d_%H%M%S")
        csv_filename = os.path.join('Accounts', f'Accounts_{datetime_string}.csv')

        # Write the new accounts data to a CSV file
        with open(csv_filename, 'w') as f:
            writer = csv.writer(f)
            writer.writerow(["Address", "Private Key"])
            for account in new_accounts:
                writer.writerow([account.address, account._private_key.hex()])

        logging.info(f'Successfully created {number_of_addresses} new accounts')

        # Fetch the current balance of the sender
        balance_url = f"https://api-sepolia.etherscan.io/api?module=account&action=balance&address={my_address}&tag=latest&apikey={api_key}"
        balance_response = requests.get(balance_url)
        balance = int(balance_response.json()["result"])  # Balance in wei
        balance_eth = w3.from_wei(balance, "ether")  # Balance in ether
        print(f"Your current balance is: {balance_eth} ETH")

        # Get the current gas price
        gas_price = w3.eth.gas_price

        # Get the current nonce of the sender
        nonce = w3.eth.get_transaction_count(my_address)

        # Prepare and send transactions
        for account in new_accounts:
            address = account.address

            # Generate a random amount to send
            amount_eth = random.uniform(0.00008, 0.01)
            amount = w3.to_wei(amount_eth, "ether")

            transaction = {
                'from': my_address,
                'to': address,
                'value': amount,
                'gas': 2000000,
                'gasPrice': gas_price,
                'nonce': nonce,  # Include the nonce field
            }
            signed_txn = w3.eth.account.sign_transaction(transaction, private_key)
            tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
            print(f'Sent {amount_eth} ETH from {my_address} to {address} in transaction {tx_hash.hex()}')
            nonce += 1  # Increment the nonce for the next transaction

            #time.sleep(random.randint(20, 40))  # Wait for a random time between 20 and 40 seconds before checking transaction status
            check_transaction_status(tx_hash)  # Check transaction status

        print('Automated mode completed! Would you like to run the consolidation script (yes/no)?')
        user_input = input().lower()
        if user_input == 'yes':
            print('Running ETHSweeper.py...')
            subprocess.run(['python3', 'ETHSweeper.py'])

    def do_estimate_fee(self, arg):
        'Estimate the transaction fee based on the current gas price.'
        try:
            gas_price = w3.eth.gas_price
            gas_price_wei = w3.from_wei(gas_price, "gwei")
            print(f'Current gas price: {gas_price_wei} gwei')

            gas_limit = 21000
            fee_wei = gas_price_wei * gas_limit
            fee_eth = w3.from_wei(fee_wei, "ether")

            # Fetching the gas prices from the Gas Oracle API
            etherscan_api_key = os.getenv("ETHERSCAN_API_KEY")
            gas_oracle_endpoint = f"https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey={etherscan_api_key}"
            response = requests.get(gas_oracle_endpoint)
            gas_oracle_data = response.json()

            # Extracting the gas prices and other relevant data from the API response
            last_block = gas_oracle_data["result"]["LastBlock"]
            safe_gas_price = gas_oracle_data["result"]["SafeGasPrice"]
            propose_gas_price = gas_oracle_data["result"]["ProposeGasPrice"]
            fast_gas_price = gas_oracle_data["result"]["FastGasPrice"]
            suggest_base_fee = gas_oracle_data["result"]["suggestBaseFee"]
            gas_used_ratio = gas_oracle_data["result"]["gasUsedRatio"]

            print('Estimated transaction fee (for a standard transaction):')
            print(f'{fee_eth} ETH')
            print(f'{fee_wei} gwei')

            # Print additional gas-related data
            print('Gas Oracle Data:')
            print(f'Last Block: {last_block}')
            print(f'Safe Gas Price: {safe_gas_price} gwei')
            print(f'Propose Gas Price: {propose_gas_price} gwei')
            print(f'Fast Gas Price: {fast_gas_price} gwei')
            print(f'Suggested Base Fee: {suggest_base_fee}')
            print(f'Gas Used Ratio: {gas_used_ratio}')

        except requests.exceptions.RequestException:
            print('Unable to connect to the Etherscan API. Please check your internet connection or API key.')

    def do_address_balance(self, arg):
        'Check the balance of a specific Ethereum address: address_balance <address>'
        try:
            address = arg.strip()
            balance_url = f"https://api-sepolia.etherscan.io/api?module=account&action=balance&address={address}&tag=latest&apikey={api_key}"
            balance_response = requests.get(balance_url)
            balance = int(balance_response.json()["result"])  # Balance in wei
            balance_eth = w3.from_wei(balance, "ether")  # Balance in ether
            print(f"The balance of address {address} is: {balance_eth} ETH")
        except web3.exceptions.ConnectivityError:
            print('Unable to connect to the Ethereum network. Please check your internet connection.')

    def do_address_history(self, arg):
        'View the transaction history for a specific Ethereum address: address_history <address>'
        try:
            address = arg.strip()
            transactions_url = f"https://api-sepolia.etherscan.io/api?module=account&action=txlist&address={address}&startblock=0&endblock=99999999&sort=desc&apikey={api_key}"
            transactions_response = requests.get(transactions_url)
            transactions = transactions_response.json()["result"]
            if len(transactions) > 0:
                print(f"Transaction history for address {address}:")
                for tx in transactions:
                    print(f"Transaction Hash: {tx['hash']}")
                    print(f"From: {tx['from']}")
                    print(f"To: {tx['to']}")
                    print(f"Value: {w3.from_wei(int(tx['value']), 'ether')} ETH")
                    print()
            else:
                print(f"No transaction history found for address {address}")
        except web3.exceptions.ConnectivityError:
            print('Unable to connect to the Ethereum network. Please check your internet connection.')

    def do_add_address_label(self, arg):
        'Add a label to an Ethereum address: add_address_label <address> <label>'
        try:
            args = arg.split()
            address = args[0].strip()
            label = ' '.join(args[1:]).strip()
            self.address_book[address] = label
            print(f"Label '{label}' added to address {address}")
        except IndexError:
            print('Invalid command format. Please use the format: add_address_label <address> <label>')

    def do_remove_address_label(self, arg):
        'Remove the label associated with an Ethereum address: remove_address_label <address>'
        try:
            address = arg.strip()
            if address in self.address_book:
                del self.address_book[address]
                print(f"Label removed from address {address}")
            else:
                print(f"No label found for address {address}")
        except IndexError:
            print('Invalid command format. Please use the format: remove_address_label <address>')

    def do_address_book(self, arg):
        'Display the list of addresses in the address book along with their labels.'
        if len(self.address_book) > 0:
            print('Address Book:')
            for address, label in self.address_book.items():
                print(f"{address}: {label}")
        else:
            print('Address book is empty.')

    def do_encrypt_private_key(self, arg):
        'Encrypt the private key using a passphrase.'
        try:
            passphrase = getpass.getpass('Enter passphrase: ')
            private_key = secrets.token_hex(32)  # Generate a new private key
            encrypted_private_key = w3.eth.account.encrypt(private_key, passphrase)
            address = Account.from_key(private_key).address  # Get the generated address
            folder_path = "Encrypted"
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)
            label = input("Enter a custom label for the encrypted key file: ")
            filename = f"encrypted_private_key_{label}.json"
            json_file = os.path.join(folder_path, filename)
            encrypted_data = {
                'private_key': encrypted_private_key,
                'address': address  # Include the address in the encrypted file
            }
            with open(json_file, 'w') as f:
                json.dump(encrypted_data, f)
            print('Private key encrypted and saved to JSON file.')
            print(f'Generated address: {address}')  # Show the generated address to the user
        except ValueError:
            print('Invalid private key.')

    def do_decrypt_private_key(self, arg):
        'Decrypt the encrypted private key using the passphrase.'
        try:
            folder_path = "Encrypted"
            if not os.path.exists(folder_path):
                print(f"No files found in the '{folder_path}' folder.")
                return

            # List files in the "Encrypted" folder
            files = os.listdir(folder_path)
            if not files:
                print(f"No files found in the '{folder_path}' folder.")
                return

            print("Encrypted private key files in the 'Encrypted' folder:")
            for i, file in enumerate(files):
                print(f"{i + 1}. {file}")

            file_number = int(input("Enter the number of the encrypted private key file: ")) - 1
            if file_number < 0 or file_number >= len(files):
                print("Invalid selection. Please try again.")
                return

            selected_file = os.path.join(folder_path, files[file_number])
            passphrase = getpass.getpass("Enter passphrase: ")
            with open(selected_file, "r") as f:
                encrypted_data = json.load(f)
            decrypted_private_key = w3.eth.account.decrypt(encrypted_data['private_key'], passphrase)
            address = encrypted_data['address']
            print(f"Decrypted private key: {decrypted_private_key.hex()}")
            print(f"Address: {address}")

            decrypted_folder_path = "Decrypted"
            if not os.path.exists(decrypted_folder_path):
                os.makedirs(decrypted_folder_path)

            decrypted_filename = f"decrypted_private_key_{address}.txt"
            decrypted_file_path = os.path.join(decrypted_folder_path, decrypted_filename)

            with open(decrypted_file_path, 'w') as f:
                f.write(f"Decrypted private key: {decrypted_private_key.hex()}\n")
                f.write(f"Address: {address}\n")

            print(f"Decrypted private key saved to {decrypted_file_path}")
        except ValueError:
            print("Incorrect passphrase.")

    def do_switch_network(self, arg):
        'Switch to a different Ethereum network by configuring the RPC endpoint.'
        new_endpoint = input('Enter the new RPC endpoint: ')
        self.infura_endpoint = new_endpoint
        print(f'RPC endpoint updated to {new_endpoint}')

    def do_exit(self, arg):
        'Exit the shell.'
        print('Goodbye!')
        return True


def check_transaction_status(tx_hash):
    """
    Check the transaction status and wait until it is confirmed.
    """
    while True:
        try:
            receipt = w3.eth.get_transaction_receipt(tx_hash)
            if receipt is None:
                print(f'Transaction {tx_hash.hex()} is still pending...')
                time.sleep(30)  # Wait for 30 seconds before checking again
            else:
                print(f'Transaction {tx_hash.hex()} Confirmed ✔')
                break
        except web3.exceptions.TransactionNotFound:
            print(f'Transaction {tx_hash.hex()} not found')
            break
        except web3.exceptions.ConnectivityError:
            print('Unable to connect to the Ethereum network. Please check your internet connection.')
            break


if __name__ == '__main__':
    # Load the private key and wallet address from the .env file
    private_key = os.getenv("PRIVATE_KEY")
    my_address = os.getenv("WALLET_ADDRESS")
    api_key = os.getenv("ETHERSCAN_API_KEY")

    if private_key is None or my_address is None or api_key is None:
        print('Please set the PRIVATE_KEY, WALLET_ADDRESS, and ETHERSCAN_API_KEY variables in the .env file.')
        sys.exit(1)

    # Connect to the Ethereum network
    w3 = Web3(Web3.HTTPProvider(EthMixerCmd.infura_endpoint))

    # Start the command line interface
    EthMixerCmd().cmdloop()
